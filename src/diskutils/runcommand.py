"""Author: Oktawiusz Wilk
Date: 30/10/2015
Source of the initial pty handling code:
"Using subprocess with select and pty hangs when capturing output",
    StackOverflow, [http://goo.gl/vzkZQu], Accessed: 28/10/2015
"""

import errno
import os
import pty
import subprocess


class OutputParser:
    """The base class for parsing modules used with Execute class"""
    def __init__(self):
        self.output = None

    def parse(self, data):
        """Parses data received and saves it in output variable"""
        self.output = data


class OutputToFileConverter(OutputParser):
    """The special Output Parser extension that allows writing output directly
    to a file in both: write and append modes and providing it as the standard
    output the way OutputParser does.
    """

    def __init__(self, target_file:str, append:bool=False):
        if append:
            self.mode = 'a'
        else:
            self.mode = 'w'
        self.file = target_file
        self.output = None

    def parse(self, data):
        self.output = data
        with open(self.file, self.mode) as fd:
            fd.write(data)


class Execute:
    """Command execution wrapper that provides support for both, line-buffering
    through tty emulation and blocking modes.
    """

    def __init__(self, command:list, output_parser:'OutputParser'=OutputParser(),
                 use_pty:bool=False, shell:bool=False, buffer_size:int=1024):
        """Add the command execution parameters to the object.
        command - the command to be executed.
        output_parser - the output parsing module to use.
        use_pty - the flag to force line-buffering for the command.
        shell - the flag to allow command in a string format.
            Warning: Executing commands from user input with shell enabled
            is considered as high security risk.
        buffer_size - the number of bytes to read at once from pty.
        """
        self.command = command
        self.output_parser = output_parser
        self.use_pty = use_pty
        self.shell = shell
        self.buffer_size = buffer_size
        self.process = None

    def run(self):
        """Start execution of the command."""
        if self.use_pty:
            return self._run_with_pty()
        else:
            return self._run_without_pty()

    def kill(self):
        """Force stop execution of the command."""
        if self.process:
            if self.process.poll() is None:
                self.process.kill()
            self.process.wait()
            return self.process.poll()
        else:
            return None

    def poll(self):
        """Return one of the following status codes for the command:
        positive int - if process has finished.
        None - if process is still running.
        -1 - if process was not started yet.
        """
        if self.process:
            return self.process.poll()
        else:
            return -1

    def output(self):
        """Return output generated by attached parser."""
        return self.output_parser.output

    def _run_with_pty(self):
        """Executes Unix command forcing the line-buffering behaviour
        and redirecting each line from stdout to output_parser,
        Warning: The pty docummentation states that this functionality
        may work only on Linux.
        """
        master_fd, slave_fd = pty.openpty()
        self.process = subprocess.Popen(self.command, stdin=slave_fd,
                                        stdout=slave_fd, stderr=subprocess.STDOUT,
                                        close_fds=False, shell=self.shell)
        os.close(slave_fd)
        while True:
            try:
                data = os.read(master_fd, self.buffer_size)
            except OSError as e:
                if e.errno == errno.EIO:
                    break  # EIO == EOF on some systems
                raise e
            else:
                if not data:  # EOF
                    break
                self.output_parser.parse(data.decode("utf-8"))
        os.close(master_fd)
        return self.kill()

    def _run_without_pty(self):
        """Executes command and passes standard output to the output_parser."""
        self.process = subprocess.Popen(self.command, stdout=subprocess.PIPE,
                                        shell=self.shell)
        out, err = self.process.communicate()
        self.output_parser.parse(out.decode("utf-8"))
        return self.kill()
