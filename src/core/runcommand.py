"""
Author:     Oktawiusz Wilk
Date:       10/04/2016
License:    GPL
Source of the initial pty handling code:
"Using subprocess with select and pty hangs when capturing output",
    StackOverflow, [http://goo.gl/vzkZQu], Accessed: 28/10/2015
"""

import errno
import os
import pty
import subprocess


class OutputParser:
    """The base class for parsing modules used with Execute class"""
    def __init__(self, silent=True):
        self.output = None
        self.silent = silent

    def parse(self, data):
        """Parses data received and saves it in output variable"""
        self.output = data
        if not self.silent:
            print(str(self.output))

class OutputToFileConverter(OutputParser):
    """The special Output Parser extension that allows writing output directly
    to a file in both: write and append modes and providing it as the standard
    output the way OutputParser does.
    """

    def __init__(self, target_file:str, append:bool=False):
        if append:
            self.mode = 'a'
        else:
            self.mode = 'w'
        self.file = target_file
        self.output = None

    def parse(self, data):
        self.output = data
        with open(self.file, self.mode) as fd:
            fd.write(data)


class Execute:
    """Command execution wrapper that provides support for both, line-buffering
    through tty emulation and blocking modes.
    """

    PROCESS_KILLED = -9
    PROCESS_NOT_STARTED = -1
    PROCESS_RUNNING = None

    def __init__(self, command:list, output_parser:'OutputParser'=OutputParser(),
                 use_pty:bool=False, shell:bool=False, buffer_size:int=1024):
        """
        Add the command execution parameters to the object.
        :param command: the command to be executed.
        :param output_parser: the output parsing module to use.
        :param use_pty: the flag to force line-buffering for the command.
        :param shell: the flag to allow command in a string format.
            Warning: Executing commands from user input with shell enabled
            is considered as high security risk.
        :param buffer_size: the number of bytes to read at once from pty.
        :return: initialised Execute object.
        """
        self.command = command
        self.output_parser = output_parser
        self.use_pty = use_pty
        self.shell = shell
        self.buffer_size = buffer_size
        self.process = None

    def run(self):
        """
        Start execution of the command.
        :return: return code of the command
        """
        if self.use_pty:
            return self._run_with_pty()
        else:
            return self._run_without_pty()

    def kill(self):
        """
        Force stop execution of the command.
        :return: return code of the killed command or None if process did not exist.
        """
        if self.process:
            if self.process.poll() is None:
                self.process.kill()
            self.process.wait()
            return self.process.poll()
        else:
            return None

    def poll(self):
        """
        Return one of the status codes for the command.
        :return:  positive int - if process has finished.
            None - if process is still running.
            -1 - if process was not started yet.
        """
        if self.process:
            return self.process.poll()
        else:
            return -1

    def output(self):
        """
        Return output generated by attached parser.
        :return: output in the format generated by the attached output parser.
        """
        return self.output_parser.output

    def _run_with_pty(self):
        """
        Executes Unix command forcing the line-buffering behaviour
        and redirecting each line from stdout to output_parser,
        Warning: The pty docummentation states that this functionality
        may work only on Linux.
        :return: return code of the executed command
        """
        master_fd, slave_fd = pty.openpty()
        self.process = subprocess.Popen(self.command, stdin=slave_fd,
                                        stdout=slave_fd, stderr=subprocess.STDOUT,
                                        close_fds=False, shell=self.shell)
        os.close(slave_fd)
        while True:
            try:
                data = os.read(master_fd, self.buffer_size)
            except OSError as e:
                if e.errno == errno.EIO:
                    break  # EIO == EOF on some systems
                raise e
            else:
                if not data:  # EOF
                    break
                self.output_parser.parse(data.decode("utf-8"))
        os.close(master_fd)
        return self.kill()

    def _run_without_pty(self):
        """
        Executes command and passes standard output to the output_parser.
        :return: return code of the executed command
        """
        self.process = subprocess.Popen(self.command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                        shell=self.shell)
        out, err = self.process.communicate()
        self.output_parser.parse(out.decode("utf-8"))
        return self.kill()
